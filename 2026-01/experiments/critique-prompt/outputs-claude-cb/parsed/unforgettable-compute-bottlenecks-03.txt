"The Algorithmic Efficiency Treadmill": The paper's fifth counterargument claims that as algorithms become more efficient, labs can run more experiments per unit compute, so both inputs grow together. But this assumes algorithmic efficiency gains are "free" cognitive outputs that don't themselves require the compute-intensive experiments being studied. In reality, discovering that your algorithms are 2Ã— more efficient likely required running experiments at near-frontier scale. The paper treats efficiency gains as a way to escape the compute constraint, but these gains are themselves the output variable (Y) in the CES model, not an independent input. This is accounting sleight-of-hand: you can't use the thing you're trying to produce as an input to producing more of it without circularity. If efficiency gains require compute to discover, then "more experiments at fixed capability" is purchased with the same scarce resource the bottleneck objection identifies.